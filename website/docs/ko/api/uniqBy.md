---
id: uniqBy
---

<!-- Do not edit this file. It is generated automatically -->

## uniqBy() function

[uniq](https://fxts.dev/ko/api/uniq)와 달리 주어진 Iterable/AsyncIterable 내부에서 `f`를 적용하여 중복 값이 제거된 Iterable/AsyncIterable을 반환합니다. 결과 값의 순서는 배열에서 발생하는 순서에 따라 결정됩니다.

**Signature:**

```typescript
declare function uniqBy<A, B>(
  f: (a: A) => B,
  iterable: Iterable<A>,
): IterableIterator<A>;
```

## Example

```ts
const iter = uniqBy(
  (a) => a.age,
  [{ age: 21 }, { age: 23 }, { age: 21 }, { age: 34 }],
);
iter.next(); // {done:false, value: {age: 21}}
iter.next(); // {done:false, value: {age: 23}}
iter.next(); // {done:false, value: {age: 34}}
iter.next(); // {done:true, value: undefined}

// with pipe
pipe(
  [{ age: 21 }, { age: 23 }, { age: 21 }, { age: 34 }],
  uniqBy((a) => a.age),
  toArray,
); // [{age: 21}, {age: 23}, {age: 34}]

await pipe(
  Promise.resolve([{ age: 21 }, { age: 23 }, { age: 21 }, { age: 34 }]),
  uniqBy((a) => a.age),
  toArray,
); // [{age: 21}, {age: 23}, {age: 34}]

// if you want to use asynchronous callback
await pipe(
  Promise.resolve([{ age: 21 }, { age: 23 }, { age: 21 }, { age: 34 }]),
  toAsync,
  uniqBy(async (a) => a.age),
  toArray,
); // [{age: 21}, {age: 23}, {age: 34}]

// toAsync
await pipe(
  [
    Promise.resolve({ age: 21 }),
    Promise.resolve({ age: 23 }),
    Promise.resolve({ age: 21 }),
    Promise.resolve({ age: 34 }),
  ],
  toAsync,
  uniqBy((a) => a.age),
  toArray,
); // [{age: 21}, {age: 23}, {age: 34}]
```

[Try It](https://codesandbox.io/s/fxts-uniqby-zb5d9)

see [pipe](https://fxts.dev/ko/api/pipe)<!-- -->, [toAsync](https://fxts.dev/ko/api/toAsync)<!-- -->, [toArray](https://fxts.dev/ko/api/toArray)

[Open Source Code](https://github.com/marpple/FxTS/blob/main/src/Lazy/uniqBy.ts)
