"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[656],{7595:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>l,frontMatter:()=>d,metadata:()=>i,toc:()=>u});var c=o(4848),t=o(8453);const d={id:"debounce"},r=void 0,i={id:"debounce",title:"debounce",description:"debounce() function",source:"@site/docs/debounce.md",sourceDirName:".",slug:"/debounce",permalink:"/docs/debounce",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"debounce"},sidebar:"api",previous:{title:"when",permalink:"/docs/when"}},s={},u=[{value:"debounce() function",id:"debounce-function",level:2},{value:"Example",id:"example",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"debounce-function",children:"debounce() function"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"debounce"})," function is used to delay the execution of a provided function until after a specified time period has passed since the last time the debounced function was invoked. The function is useful to optimize performance by limiting the rate at which a function is executed, especially in scenarios like handling user input events, scrolling, or resizing. Additionally, the debounce function allows you to execute the function immediately on the first call (when leading is set to true), and it can be canceled manually using the ",(0,c.jsx)(n.code,{children:".cancel()"})," method."]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"declare function debounce<T extends (...args: any[]) => void>(func: T, wait: number, options?: {\r\n    leading: boolean;\r\n}): ((...args: Parameters<T>) => void) & {\r\n    cancel: () => void;\r\n};\n"})}),"\n",(0,c.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"const debounced1 = debounce((val: number)=>{\r\n  console.log('val', val);\r\n}, 100);\r\n\r\ndebounced1();\r\ndebounced1();\r\ndebounced1(); // invoke func after 100ms\r\n\r\nconst debounced2 = debounce((val: number)=>{\r\n  console.log('val', val);\r\n}, 100, { leading:true });\r\ndebounced2(); // immediately invoked func\r\ndebounced2();\r\ndebounced2(); // invoked func after 100ms\r\n\r\n\r\nconst debounced3 = debounce((val: number)=>{\r\n  console.log('val', val);\r\n}, 100);\r\ndebounced3();\r\ndebounced3();\r\ndebounced3.cancel(); // cancel func\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://github.com/marpple/FxTS/blob/main/src/debounce.ts",children:"Open Source Code"})})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>i});var c=o(6540);const t={},d=c.createContext(t);function r(e){const n=c.useContext(d);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),c.createElement(d.Provider,{value:n},e.children)}}}]);