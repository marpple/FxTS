"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3346],{6581:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var t=r(4848),s=r(8453);const o={id:"transpose"},a=void 0,i={id:"transpose",title:"transpose",description:"transpose() function",source:"@site/docs/transpose.md",sourceDirName:".",slug:"/transpose",permalink:"/docs/transpose",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"transpose"},sidebar:"api",previous:{title:"toAsync",permalink:"/docs/toAsync"},next:{title:"uniq",permalink:"/docs/uniq"}},p={},c=[{value:"transpose() function",id:"transpose-function",level:2},{value:"Example",id:"example",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"transpose-function",children:"transpose() function"}),"\n",(0,t.jsx)(n.p,{children:"The transpose function takes multiple iterators as input and returns a transposed 2D array\u2014swapping rows with columns."}),"\n",(0,t.jsx)(n.p,{children:"Unlike the existing zip function, transpose behaves as shown in the example below:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"declare function transpose<T extends UniversalIterable, R extends UniversalIterable[]>(iterables: T): (...args: R) => ReturnZipType<[T, ...R]>;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const iter = transpose([1, 'a'], [2, 'b'], [3, 'c']);\r\niter.next() // {done:false, value: [1, 2, 3]}\r\niter.next() // {done:false, value: ['a', 'b', 'c']}\r\niter.next() // {done:true, value: undefined}\r\n\r\nconst iter = transpose([1, 2, 3], ['a', 'b', 'c']);\r\niter.next() // {done:false, value: [1, 'a']}\r\niter.next() // {done:false, value: [2, 'b']}\r\niter.next() // {done:false, value: [3, 'c']}\r\niter.next() // {done:true, value: undefined}\r\n\r\n// How transpose differs from `zip`\r\nconst iter = zip([1, 2], [3], [], [4, 5, 6], [7], [8, 9]);\r\niter.next() // {done:true, value: undefined}\r\n// Because zip stops at the shortest input, passing an empty array causes it to exit immediately.\r\n\r\n// with pipe\r\npipe(\r\n  [4, 5, 6, 7],\r\n  transpose([1, 2, 3]),\r\n  toArray,\r\n) // [[ 1, 4 ], [ 2, 5 ], [ 3, 6 ], [7]]\r\n\r\npipe(\r\n  Promise.resolve([4, 5, 6, 7]),\r\n  transpose([1, 2, 3]),\r\n  toArray,\r\n) // [[ 1, 4 ], [ 2, 5 ], [ 3, 6 ], [7]]\r\n\r\n// with toAsync\r\npipe(\r\n  [Promise.resolve(4), Promise.resolve(5), Promise.resolve(6), Promise.resolve(7)],\r\n  toAsync,\r\n  transpose([1, 2, 3]),\r\n  toArray,\r\n) // [[ 1, 4 ], [ 2, 5 ], [ 3, 6 ], [7]]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://github.com/marpple/FxTS/blob/main/src/Lazy/transpose.ts",children:"Open Source Code"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);